/* warp-charger
 * Copyright (C) 2020-2021 Erik Fleckstein <erik@tinkerforge.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

#include <Arduino.h>
#include <WiFi.h>
#include <SPIFFS.h>

#include <stdio.h>
#include <string.h>

#include "ESPAsyncWebServer.h"
#include "AsyncJson.h"

#include "hal_arduino_esp32/hal_arduino_esp32.h"

#include "bindings/errors.h"
#include "bindings/endian_convert.h"
#include "bindings/packetbuffer.h"
#include "bindings/spitfp.h"

#include "index.html.h"
{{{module_includes}}}

#include "api.h"
#include "event_log.h"
#include "task_scheduler.h"

#ifdef warp
#define GREEN_LED 4
#define BLUE_LED 32
#endif

#ifdef warp4mb
#define GREEN_LED 25
#define BLUE_LED 33
#endif

#ifdef warp8enplus
#define GREEN_LED 25
#define BLUE_LED 33
#endif

#ifdef warp4sdr3
#define GREEN_LED 13  // this led is blue on the Sonoff DUAL R3
#define BLUE_LED 9    // There is no second LED on the SDR3 and we need no blinking
#endif

AsyncWebServer server(80);

EventLog logger;

TF_HalContext hal;
TaskScheduler task_scheduler;
API api;

{{{module_decls}}}

uint32_t uid_numeric = 0;
char uid[7] = {0};
char passphrase[20] = {0};
bool firmware_update_allowed = true;

TF_Port ports[] = {{
        .chip_select_pin = 16,
        .spi = VSPI,
        .port_name = 'A'
#ifdef warp
    }, {
        .chip_select_pin = 33,
        .spi = VSPI,
        .port_name = 'B'
    }, {
        .chip_select_pin = 17,
        .spi = VSPI,
        .port_name = 'C'
    }, {
        .chip_select_pin = 25,
        .spi = HSPI,
        .port_name = 'D'
    }, {
        .chip_select_pin = 26,
        .spi = HSPI,
        .port_name = 'E'
    }, {
        .chip_select_pin = 27,
        .spi = HSPI,
        .port_name = 'F'
#endif
    }
};

Config version;
Config modules;
Config reboot;

AsyncCallbackWebHandler *main_page_handler;

void register_default_urls() {
    server.onNotFound([](AsyncWebServerRequest *request) {
        if (request->method() == HTTP_OPTIONS)
            request->send(200);
        else
            request->send(404, "text/html", "404");
    });

    main_page_handler = &server.on("/", HTTP_GET, [](AsyncWebServerRequest *request) {
        auto *response = request->beginChunkedResponse("text/html", [](uint8_t *buffer, size_t maxLen, size_t index) -> size_t {
            auto CHUNK_SIZE = 1024 * 10;
            //Write up to "maxLen" bytes into "buffer" and return the amount written.
            //index equals the amount of bytes that have been already sent
            //You will be asked for more data until 0 is returned
            //Keep in mind that you can not delay or yield waiting for more data!
            size_t to_write = MIN(MIN(CHUNK_SIZE, maxLen), index_html_gz_len - index);
            memcpy(buffer, index_html_gz + index, to_write);
            return to_write;
        });

        response->addHeader("Content-Encoding", "gzip");
        response->addHeader("ETag", String((uint32_t)(_BUILD_TIME_), 16));
        response->setCode(200);
        request->send(response);
    });

    reboot = Config::Null();
    api.addCommand("reboot", &reboot, {}, []() {
        ESP.restart();
    }, true);

    api.addState("version", &version, {}, 10000);
    api.addState("modules", &modules, {}, 10000);

    server.on("/force_reboot", HTTP_ANY, [](AsyncWebServerRequest *request) {
        ESP.restart();
        request->send(200, "text/html", "Forced reboot.");
    });

    server.on("/uptime", HTTP_GET, [](AsyncWebServerRequest *request) {
        request->send(200, "text/html", String(millis()));
    });

    api.registerDebugUrl(&server);
}

void setup(void) {
    Serial.begin(115200);

    String firmware_version = String((uint32_t)_MAJOR_, 10) + "." +  String((uint32_t)_MINOR_, 10) + "." +  String((uint32_t)_PATCH_, 10) + "-" +  String((uint32_t)(_BUILD_TIME_), 16);
    logger.printfln("    **** TINKERFORGE {{{display_name}}} V%s ****",firmware_version.c_str());
    logger.printfln("         %dK RAM SYSTEM   %d HEAP BYTES FREE", ESP.getHeapSize()/1024, ESP.getFreeHeap());
    logger.printfln("READY.");

    if(!mount_or_format_spiffs()) {
        logger.printfln("Failed to mount SPIFFS.");
    }

    String spiffs_version = read_or_write_config_version(firmware_version);

    logger.printfln("{{{display_name}}} SPIFFS version %s", spiffs_version.c_str());

    version = Config::Object({
        {"firmware", Config::Str(firmware_version)},
        {"spiffs", Config::Str(spiffs_version)},
    });

#ifdef warp
    check(tf_hal_create(&hal, ports, sizeof(ports)/sizeof(ports[0])), "hal create");
    tf_hal_set_timeout(&hal, 100000);

    read_efuses(&uid_numeric, uid, passphrase);
#endif

    api.setup();
    task_scheduler.setup();

    {{{module_setup}}}

    modules = Config::Object({
        // Fake that the event_log is a module for now.
        {"event_log", Config::Bool(true)},
        {{{module_init_config}}}
    });

    register_default_urls();
    logger.register_urls();
    task_scheduler.register_urls();

    {{{module_register_urls}}}

    pinMode(GREEN_LED, OUTPUT);
    pinMode(BLUE_LED, OUTPUT);
    pinMode(0, INPUT);

#ifndef warp4sdr3
    task_scheduler.scheduleWithFixedDelay("led_blink", [](){
        static bool led_blink_state = false;
        led_blink_state = !led_blink_state;
        digitalWrite(BLUE_LED, led_blink_state ? HIGH : LOW);
    }, 0, 1000);
#endif



    server.begin();
}

void loop(void) {
#ifdef warp
    //prioritize proxy performance over web interface and wifi responsitivity
    tf_hal_tick(&hal, 1000);
    tf_hal_tick(&hal, 1000);
    tf_hal_tick(&hal, 1000);
    tf_hal_tick(&hal, 1000);
    tf_hal_tick(&hal, 1000);
    tf_hal_tick(&hal, 1000);
    tf_hal_tick(&hal, 1000);
    tf_hal_tick(&hal, 1000);
#endif

    task_scheduler.loop();
    api.loop();

    {{{module_loop}}}

    digitalWrite(GREEN_LED, digitalRead(0));
    //delay(5); // test if the chip gets less hot with the delay and still gets the job done
}
